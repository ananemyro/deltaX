<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gravitational Slingshot Simulator</title>
  <style>
    :root{
      --bg:#050506;
      --panel:#0d0f14;
      --panel2:#0a0c10;
      --text:#e8eef7;
      --muted:#9aa6b2;
      --accent:#5fe3ff;
      --good:#6dff57;
      --bad:#ff4d4d;
      --unknown:#cfcfcf;
      --ship:#54f0ff;
      --stroke:rgba(255,255,255,.16);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    .wrap{display:grid; grid-template-columns: 1fr 360px; gap:14px; height:100%; padding:14px; box-sizing:border-box;}
    .stage{position:relative; border:1px solid var(--stroke); border-radius:18px; overflow:hidden; background:radial-gradient(1200px 800px at 40% 40%, rgba(120,160,255,.08), rgba(0,0,0,0) 55%);}
    canvas{width:100%; height:100%; display:block;}
    .hudTop{position:absolute; left:14px; top:14px; display:flex; flex-direction:column; gap:10px; pointer-events:none;}
    .pill{pointer-events:none; display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius:999px; background:rgba(20,24,34,.72); border:1px solid var(--stroke); backdrop-filter: blur(6px); }
    .pill .label{font-size:12px; color:var(--muted); margin-right:6px;}
    .pill .value{font-weight:600; font-size:13px;}
    .progressBar{width:240px; height:10px; border-radius:999px; background:rgba(255,255,255,.10); overflow:hidden; border:1px solid rgba(255,255,255,.12);}
    .progressFill{height:100%; width:0%; background:linear-gradient(90deg, rgba(95,227,255,.95), rgba(109,255,87,.9));}
    .side{
      border:1px solid var(--stroke);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(10,12,16,.92), rgba(10,12,16,.72));
      padding:14px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:14px;
      overflow:auto;
    }
    .card{background:rgba(0,0,0,.25); border:1px solid var(--stroke); border-radius:16px; padding:12px;}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .title{font-weight:700; font-size:14px; letter-spacing:.2px;}
    .sub{font-size:12px; color:var(--muted); margin-top:2px;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:650;
      transition:transform .04s ease, background .15s ease;
    }
    button:hover{background:rgba(255,255,255,.10);}
    button:active{transform:translateY(1px);}
    .primary{background:rgba(95,227,255,.18); border-color:rgba(95,227,255,.35);}
    .primary:hover{background:rgba(95,227,255,.24);}
    .danger{background:rgba(255,77,77,.14); border-color:rgba(255,77,77,.35);}
    .danger:hover{background:rgba(255,77,77,.20);}
    .toggleOn{background:rgba(109,255,87,.16); border-color:rgba(109,255,87,.34);}
    input[type="range"]{width:100%;}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; align-items:center; font-size:13px;}
    .kv .k{color:var(--muted);}
    .kv .v{font-weight:650;}
    .hint{font-size:12px; color:var(--muted); line-height:1.35;}
    .joystick{
      width:190px; height:190px; border-radius:999px;
      border:1px solid rgba(95,227,255,.28);
      background:radial-gradient(closest-side, rgba(95,227,255,.14), rgba(0,0,0,0) 70%);
      position:relative;
      margin:10px auto 2px auto;
      touch-action:none;
      user-select:none;
    }
    .knob{
      width:38px; height:38px; border-radius:999px;
      background:rgba(95,227,255,.85);
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      box-shadow:0 10px 30px rgba(95,227,255,.18);
    }
    .joystickLabel{display:flex; justify-content:space-between; font-size:12px; color:var(--muted); margin-top:6px;}
    .statusPill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; border:1px solid var(--stroke); background:rgba(255,255,255,.05); font-size:12px;}
    .dot{width:8px; height:8px; border-radius:99px; background:rgba(255,255,255,.35);}
    .dot.good{background:var(--good);}
    .dot.bad{background:var(--bad);}
    .dot.run{background:var(--accent);}
    .dot.wait{background:rgba(255,255,255,.35);}
    .footerNote{font-size:12px; color:var(--muted); text-align:center;}
    a{color:var(--accent);}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Stage -->
    <div class="stage">
      <canvas id="c"></canvas>

      <!-- Top-left HUD like in sketch -->
      <div class="hudTop">
        <div class="pill" style="width: 300px;">
          <div style="display:flex; flex-direction:column; gap:8px;">
            <div style="display:flex; justify-content:space-between; width:100%;">
              <span class="label">progression chart</span>
              <span class="value" id="progressText">0%</span>
            </div>
            <div class="progressBar">
              <div class="progressFill" id="progressFill"></div>
            </div>
          </div>
        </div>

        <div class="pill">
          <span class="label">current speed</span>
          <span class="value" id="speedText">0.00</span>
          <span class="label" style="margin-left:10px;">success</span>
          <span class="value" id="probText">0%</span>
        </div>
      </div>
    </div>

    <!-- Side panel -->
    <div class="side">
      <div class="card">
        <div class="row">
          <div>
            <div class="title">Controls</div>
          </div>
          <div class="statusPill" id="statusPill">
            <span class="dot wait" id="statusDot"></span>
            <span id="statusText">ready</span>
          </div>
        </div>

        <div style="display:flex; gap:10px; margin-top:12px;">
          <button class="danger" id="resetBtn" style="flex:1;">↺ Reset</button>
        </div>
       </div>

      <div class="card">
        <div class="title">Trajectory control</div>
        <div class="joystick" id="joystick">
          <div class="knob" id="knob"></div>
        </div>
        <div class="sub">Magnitude: <span id="joystickMag">0.00</span></div>
      </div>

      <div class="card">
        <div class="title">Journey</div>
        <div class="sub">Live metrics from backend</div>

        <div class="kv" style="margin-top:10px;">
          <div class="k">Distance to destination</div><div class="v" id="distText">—</div>
          <div class="k">Speed</div><div class="v" id="speedText2">—</div>
          <div class="k">Success probability</div><div class="v" id="probText2">—</div>
          <div class="k">Time</div><div class="v" id="timeText">—</div>
        </div>

        <div class="hint" style="margin-top:10px;">
          Planets are <b style="color:var(--unknown);">white</b> until reached, then reveal:
          <b style="color:var(--good);">green</b> = good, <b style="color:var(--bad);">red</b> = bad.
        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Config
    // -----------------------------
    const API = "http://127.0.0.1:5000/api";
    const STEP_DT = 0.016; // UI step tick; backend clamps anyway

    // Visual tuning
    const STAR_COUNT = 120;
    const SHIP_SIZE = 10;
    const DEST_EDGE_ARROW_SIZE = 22;

    // Drag-to-plan tuning
    const DRAG_MAX_PIXELS = 220;        // clamp arrow length on screen
    const PIXELS_TO_WORLD_BASE = 0.015; // base conversion; final = base / zoom

    // -----------------------------
    // Canvas setup
    // -----------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Background stars (static in screen space)
    const stars = Array.from({length: STAR_COUNT}, () => ({
      x: Math.random(),
      y: Math.random(),
      r: Math.random() * 1.6 + 0.2,
      a: Math.random() * 0.6 + 0.2
    }));

    // -----------------------------
    // UI elements
    // -----------------------------
    const resetBtn = document.getElementById("resetBtn");

    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");
    const speedText = document.getElementById("speedText");
    const probText = document.getElementById("probText");

    const distText = document.getElementById("distText");
    const speedText2 = document.getElementById("speedText2");
    const probText2 = document.getElementById("probText2");
    const timeText = document.getElementById("timeText");

    const statusPill = document.getElementById("statusPill");
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");

    // Joystick
    const joystick = document.getElementById("joystick");
    const knob = document.getElementById("knob");
    const joystickMag = document.getElementById("joystickMag");

    // -----------------------------
    // State
    // -----------------------------
    let state = null;
    let running = false;
    let started = false;
    let initialDistance = null;

    // Drag-to-vector on canvas
    let dragActive = false;
    let dragStart = null;   // {x,y} in screen coords (CSS px)
    let dragNow = null;     // {x,y}
    let plannedDV = {dvx: 0, dvy: 0}; // world units

    // Joystick vector (world dv)
    let joyActive = false;
    let joyVec = {x: 0, y: 0}; // normalized-ish in [-1,1]

    // Local render camera (frontend authoritative for centering)
    let renderCam = { cx: 0, cy: 0, zoom: 1.0 };

    // Camera follow tuning
    const CAM_ALPHA_UI = 0.18;   // higher = snaps more to ship
    const LOOKAHEAD_UI = 12.0;   // smaller = less ship drifting

    // Trail in world coords (for nice feel)
    const trail = [];
    const TRAIL_MAX = 600;

    // -----------------------------
    // Helpers: world<->screen
    // -----------------------------
    function worldToScreen(wx, wy) {
      const zoom = renderCam.zoom || 1.0;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      return {
        x: (wx - renderCam.cx) * zoom + w / 2,
        y: (renderCam.cy - wy) * zoom + h / 2
      };
    }

    function screenToWorld(sx, sy) {
      const zoom = renderCam.zoom || 1.0;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      return {
        x: (sx - w / 2) / zoom + renderCam.cx,
        y: renderCam.cy - (sy - h / 2) / zoom
      };
    }

    function updateRenderCamera() {
      if (!state) return;

      const r = state.rocket;
      const z = (state.camera && state.camera.zoom) ? state.camera.zoom : 1.0;
      renderCam.zoom = z;

      // target: ship + small lookahead
      const tx = r.x + r.vx * LOOKAHEAD_UI;
      const ty = r.y + r.vy * LOOKAHEAD_UI;

      // init on first frame
      if (!Number.isFinite(renderCam.cx)) {
        renderCam.cx = r.x; renderCam.cy = r.y;
      }

      renderCam.cx += (tx - renderCam.cx) * CAM_ALPHA_UI;
      renderCam.cy += (ty - renderCam.cy) * CAM_ALPHA_UI;
    }

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function len(x,y){ return Math.sqrt(x*x+y*y); }
    function unit(x,y){
      const n = len(x,y);
      if (n < 1e-9) return {x:0,y:0};
      return {x:x/n,y:y/n};
    }

    // -----------------------------
    // API calls
    // -----------------------------
    async function apiGetState() {
      const res = await fetch(`${API}/state`);
      state = await res.json();
      return state;
    }

    async function apiReset(seed=null) {
      const body = seed == null ? {} : {seed};
      const res = await fetch(`${API}/reset`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(body)
      });
      state = await res.json();
      initialDistance = state.hud.distance_to_destination;
      trail.length = 0;
      trail.push({x: state.rocket.x, y: state.rocket.y});
      plannedDV = {dvx: 0, dvy: 0};
      updateHUD();
      return state;
    }

    async function apiStep(dt) {
      const res = await fetch(`${API}/step`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({dt})
      });
      state = await res.json();
      trail.push({x: state.rocket.x, y: state.rocket.y});
      if (trail.length > TRAIL_MAX) trail.shift();
      updateHUD();
      return state;
    }

    async function apiPlan(dvx, dvy) {
      const res = await fetch(`${API}/plan`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({dvx, dvy})
      });
      state = await res.json();
      updateHUD();
      return state;
    }

    // -----------------------------
    // HUD / status updates
    // -----------------------------
    function setStatus(kind, text){
      statusText.textContent = text;
      statusDot.className = "dot " + kind;
    }

    function updateHUD(){
      if (!state) return;

      const d = state.hud.distance_to_destination;
      const v = state.hud.speed;
      const p = state.hud.success_probability;

      // Progress
      if (initialDistance == null) initialDistance = d;
      const prog = clamp(1 - d / Math.max(1e-6, initialDistance), 0, 1);
      progressFill.style.width = `${(prog*100).toFixed(1)}%`;
      progressText.textContent = `${Math.round(prog*100)}%`;

      speedText.textContent = v.toFixed(2);
      probText.textContent = `${Math.round(p*100)}%`;

      distText.textContent = d.toFixed(1);
      speedText2.textContent = v.toFixed(2);
      probText2.textContent = `${Math.round(p*100)}%`;
      timeText.textContent = state.t.toFixed(2);

      // Status
      if (state.hud.status === "success"){
        setStatus("good", "success");
        running = true;
      } else if (state.hud.status === "failed"){
        setStatus("bad", "failed");
        running = true;
      } else {
        if (running) setStatus("run", "running");
        else setStatus("wait", "ready");
      }
    }

    // -----------------------------
    // Drawing
    // -----------------------------
    function drawStars() {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      for (const s of stars) {
        ctx.beginPath();
        ctx.arc(s.x*w, s.y*h, s.r, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255,255,255,${s.a})`;
        ctx.fill();
      }
    }

    function drawTrail() {
      if (!state || trail.length < 2) return;
      ctx.beginPath();
      for (let i=0;i<trail.length;i++){
        const p = trail[i];
        const sp = worldToScreen(p.x, p.y);
        if (i===0) ctx.moveTo(sp.x, sp.y);
        else ctx.lineTo(sp.x, sp.y);
      }
      ctx.strokeStyle = "rgba(95,227,255,0.22)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPlanets() {
  for (const p of state.planets) {
    const sp = worldToScreen(p.x, p.y);
    const radius = p.radius * state.camera.zoom;

    ctx.save();
    ctx.translate(sp.x, sp.y);

    // 1. Draw Rings for Large Planets (Gas Giants)
    if (p.mass > 2500 || p.color === "green") {
      ctx.beginPath();
      ctx.ellipse(0, 0, radius * 2.2, radius * 0.8, Math.PI / 6, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // 2. Planet Body Gradient (Makes it look like a sphere)
    const grad = ctx.createRadialGradient(-radius/3, -radius/3, radius/10, 0, 0, radius);
    if (p.color === "green") {
      grad.addColorStop(0, "#a2f3a2"); // Highlight
      grad.addColorStop(1, "#27ae60"); // Shadow
    } else if (p.color === "red") {
      grad.addColorStop(0, "#ff7675");
      grad.addColorStop(1, "#c0392b");
    } else {
      grad.addColorStop(0, "#dfe6e9");
      grad.addColorStop(1, "#636e72");
    }

    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();

    // 3. Add Details (Craters for small/red planets, Clouds for green)
    ctx.globalAlpha = 0.3;
    if (p.color === "red" || p.radius < 40) {
      // Draw 3 random craters
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.beginPath(); ctx.arc(-radius/2, radius/4, radius/5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(radius/3, -radius/3, radius/6, 0, Math.PI*2); ctx.fill();
    } else {
      // Draw a "cloud band" across the middle
      ctx.fillStyle = "white";
      ctx.fillRect(-radius, -radius/4, radius*2, radius/2);
    }
    ctx.globalAlpha = 1.0;

    // 4. Atmosphere Glow
    ctx.beginPath();
    ctx.arc(0, 0, radius + 5, 0, Math.PI * 2);
    ctx.strokeStyle = p.color === "green" ? "rgba(46, 204, 113, 0.2)" : "rgba(231, 76, 60, 0.2)";
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.restore();
  }
}

    // Version2: this is the cool version (has animated flames!)
    function drawShip() {
      const r = state.rocket;
      const sp = worldToScreen(r.x, r.y);

      ctx.save();
      ctx.translate(sp.x, sp.y);

      // Use the velocity angle (world Y is up, screen Y is down)
      const ang = Math.atan2(r.vy, r.vx);
      ctx.rotate(-ang);

      const scale = 1.4;

      // --------------------
      // 1. Engine Flame (Multi-layered Glow)
      // --------------------
      const speed = Math.sqrt(r.vx * r.vx + r.vy * r.vy);
      if (speed > 0.1) {
        const flicker = Math.random() * 5;
        const flameLen = (15 + speed * 5) * scale + flicker;

        // Outer Orange Glow
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.quadraticCurveTo(-15, -8, -10 - flameLen, 0);
        ctx.quadraticCurveTo(-15, 8, -10, 0);
        ctx.fillStyle = "rgba(255, 120, 0, 0.6)";
        ctx.fill();

        // Inner Yellow Core
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.quadraticCurveTo(-12, -4, -10 - (flameLen * 0.6), 0);
        ctx.quadraticCurveTo(-12, 4, -10, 0);
        ctx.fillStyle = "rgba(255, 255, 100, 0.9)";
        ctx.fill();
      }

      // --------------------
      // 2. Fins (Swept Back)
      // --------------------
      ctx.fillStyle = "#e74c3c"; // Red fins like the image
      ctx.beginPath();
      // Top Fin
      ctx.moveTo(-4, -6);
      ctx.bezierCurveTo(-15, -15, -20, -15, -12, -6);
      // Bottom Fin
      ctx.moveTo(-4, 6);
      ctx.bezierCurveTo(-15, 15, -20, 15, -12, 6);
      ctx.fill();

      // --------------------
      // 3. Main Body (Metallic Gradient)
      // --------------------
      const bodyGrad = ctx.createLinearGradient(0, -10, 0, 10);
      bodyGrad.addColorStop(0, "#ffffff");
      bodyGrad.addColorStop(0.5, "#dcdde1");
      bodyGrad.addColorStop(1, "#bdc3c7");

      ctx.beginPath();
      ctx.moveTo(20 * scale, 0); // Nose tip
      // Top curve
      ctx.bezierCurveTo(15 * scale, -10 * scale, -10 * scale, -10 * scale, -12 * scale, 0);
      // Bottom curve
      ctx.bezierCurveTo(-10 * scale, 10 * scale, 15 * scale, 10 * scale, 20 * scale, 0);
      ctx.fillStyle = bodyGrad;
      ctx.fill();

      // --------------------
      // 4. Nose Cone (Red Tip)
      // --------------------
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(20 * scale, 0);
      ctx.bezierCurveTo(18 * scale, -5 * scale, 12 * scale, -6 * scale, 10 * scale, -7 * scale);
      ctx.lineTo(10 * scale, 7 * scale);
      ctx.bezierCurveTo(12 * scale, 6 * scale, 18 * scale, 5 * scale, 20 * scale, 0);
      ctx.clip(); // Only paint the tip red
      ctx.fillStyle = "#e74c3c";
      ctx.fill();
      ctx.restore();

      // --------------------
      // 5. Window
      // --------------------
      ctx.beginPath();
      ctx.arc(2, 0, 3.5, 0, Math.PI * 2);
      ctx.fillStyle = "#3498db";
      ctx.fill();
      ctx.strokeStyle = "#2980b9";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    function clampDV(dvx, dvy) {
      // Backend clamps too, but matching here feels better
      const DV_MAX = 3.0;
      const m = len(dvx, dvy);
      if (m <= DV_MAX) return {dvx, dvy};
      const u = unit(dvx, dvy);
      return {dvx: u.x * DV_MAX, dvy: u.y * DV_MAX};
    }

    function drawDestinationAndArrow() {
      const dest = state.destination;
      const rocket = state.rocket;

      const ds = worldToScreen(dest.x, dest.y);
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      // 1. Logic for "Pulsing" effect using Time
      const pulse = Math.sin(Date.now() / 200) * 1.5;             // Compresses/Expands over time
      const opacity = 0.5 + Math.sin(Date.now() / 200) * 0.1;   // Glow intensity

      const onScreen = (ds.x >= -60 && ds.x <= w+60 && ds.y >= -60 && ds.y <= h+60);

        // 1. Logic for "Pulsing" effect using Time
      if (onScreen) {
      // Draw destination circle with soft glow
      ctx.beginPath();
      ctx.arc(ds.x, ds.y, (dest.radius * state.camera.zoom) + pulse, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(95, 227, 255, ${opacity})`;
      ctx.lineWidth = 2.5; // Slightly thinner line for elegance
      ctx.stroke();

      ctx.fillStyle = "rgba(95,227,255,0.9)";
      ctx.font = "12px system-ui";
      ctx.fillText("TARGET", ds.x + 12, ds.y - 12);
    }

      // 2. The Edge Indicator (The "Glow" Pointer)
      const shipS = worldToScreen(rocket.x, rocket.y);
      const vx = ds.x - shipS.x;
      const vy = ds.y - shipS.y;
      const distPixels = Math.sqrt(vx*vx + vy*vy);

      const pad = 40; // More breathing room from the edge
      const minX = pad, maxX = w - pad, minY = pad, maxY = h - pad;

      let ax = ds.x, ay = ds.y;

      if (!onScreen) {
        const cx = w/2, cy = h/2;
        const rx = ds.x - cx, ry = ds.y - cy;
        const tCandidates = [];
        if (Math.abs(rx) > 1e-6) { tCandidates.push((minX - cx) / rx); tCandidates.push((maxX - cx) / rx); }
        if (Math.abs(ry) > 1e-6) { tCandidates.push((minY - cy) / ry); tCandidates.push((maxY - cy) / ry); }

        let best = null;
        for (const t of tCandidates) {
          if (t <= 0) continue;
          const x = cx + rx * t; const y = cy + ry * t;
          if (x >= minX-2 && x <= maxX+2 && y >= minY-2 && y <= maxY+2) {
            if (best === null || t < best.t) best = {t, x, y};
          }
        }
        if (best) { ax = best.x; ay = best.y; }
      }

      const ang = Math.atan2(vy, vx);

      // 3. Drawing the "Compressing" Glowing Arrow
      ctx.save();
      ctx.translate(ax, ay);
      ctx.rotate(ang);

      // Add Outer Glow
      ctx.shadowBlur = 15;
      ctx.shadowColor = "rgba(95, 227, 255, 0.8)";

      ctx.beginPath();
      // The arrow "compresses" (moves back and forth) based on the pulse variable
      const arrowHeadSize = DEST_EDGE_ARROW_SIZE + (onScreen ? 0 : pulse);
      ctx.moveTo(0, 0);
      ctx.lineTo(-arrowHeadSize, -arrowHeadSize/1.5);
      ctx.lineTo(-arrowHeadSize * 0.7, 0); // Notched back for a tech look
      ctx.lineTo(-arrowHeadSize, arrowHeadSize/1.5);
      ctx.closePath();

      ctx.fillStyle = `rgba(95, 227, 255, ${onScreen ? 0.3 : 0.9})`;
      ctx.fill();
      ctx.restore();

      // 4. Distance Text (Written indicator)
      if (!onScreen) {
        ctx.fillStyle = `rgba(95, 227, 255, ${opacity})`;
        ctx.font = "bold 12px monospace";
        const distKm = Math.floor(distPixels / 10);
        ctx.fillText(`${distKm}km`, ax - 20, ay + 30);
      }
      // "General direction of destination" label (like sketch)
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.font = "12px system-ui, sans-serif";
    }

    function render() {
      if (!state) return;

      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx.clearRect(0,0,w,h);

      drawStars();
      drawTrail();
      drawPlanets();
      drawDestinationAndArrow();
      drawShip();
      drawJoystickVector();
    }

    function drawJoystickVector() {
      if (!state) return;

      const r = state.rocket;
      const ship = worldToScreen(r.x, r.y);

      const arrowPx = 110 * Math.min(1, len(joyVec.x, joyVec.y));

      const vx = joyVec.x;
      const vy = -joyVec.y; // invert screen y

      const end = { x: ship.x + vx * arrowPx, y: ship.y + vy * arrowPx };

      ctx.beginPath();
      ctx.moveTo(ship.x, ship.y);
      ctx.lineTo(end.x, end.y);
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // arrow head
      const a = Math.atan2(end.y - ship.y, end.x - ship.x);
      const head = 10;
      ctx.beginPath();
      ctx.moveTo(end.x, end.y);
      ctx.lineTo(end.x - head * Math.cos(a - 0.5), end.y - head * Math.sin(a - 0.5));
      ctx.lineTo(end.x - head * Math.cos(a + 0.5), end.y - head * Math.sin(a + 0.5));
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.font = "12px system-ui, sans-serif";
    }

    // -----------------------------
    // Interaction: canvas drag
    // -----------------------------
    function isNearShip(screenX, screenY) {
      const r = state.rocket;
      const sp = worldToScreen(r.x, r.y);
      return len(screenX - sp.x, screenY - sp.y) < 26;
    }

    function canvasPointerPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left);
      const y = (evt.clientY - rect.top);
      return {x, y};
    }

    // -----------------------------
    // Controls: reset
    // -----------------------------
    resetBtn.addEventListener("click", async () => {
      await apiReset();   // resets planets + rocket + camera
      started = false;

      // reset joystick UI
      joyVec = {x: 0, y: 0};
      setKnob(0, 0);
      joystickMag.textContent = "0.00";
    });

    // -----------------------------
    // Joystick nudge (optional)
    // -----------------------------
    function setKnob(nx, ny) {
      // nx,ny in [-1,1]
      const r = joystick.getBoundingClientRect();
      const radius = Math.min(r.width, r.height) * 0.38;
      const x = nx * radius;
      const y = ny * radius;

      knob.style.left = `calc(50% + ${x}px)`;
      knob.style.top  = `calc(50% + ${y}px)`;
    }

    function joystickPointer(evt) {
      const r = joystick.getBoundingClientRect();
      const x = evt.clientX - r.left - r.width/2;
      const y = evt.clientY - r.top - r.height/2;
      const radius = Math.min(r.width, r.height) * 0.38;
      const m = Math.max(1e-6, Math.min(radius, Math.sqrt(x*x+y*y)));
      const nx = x / radius;
      const ny = y / radius;
      // clamp to circle
      const mm = Math.sqrt(nx*nx+ny*ny);
      const cx = mm > 1 ? nx/mm : nx;
      const cy = mm > 1 ? ny/mm : ny;
      return {nx: cx, ny: cy, mag: Math.min(1, mm)};
    }

    const JOY_DV_MAX = 3.0;   // matches backend clamp
    const JOY_GAIN = 3.0;     // feel/tuning constant

    joystick.addEventListener("pointerdown", (evt) => {
      joyActive = true;
      joystick.setPointerCapture(evt.pointerId);

      const j = joystickPointer(evt);
      joyVec = {x: j.nx, y: j.ny};
      setKnob(joyVec.x, joyVec.y);
      joystickMag.textContent = j.mag.toFixed(2);
    });

    joystick.addEventListener("pointermove", (evt) => {
      if (!joyActive) return;

      const j = joystickPointer(evt);
      joyVec = {x: j.nx, y: j.ny};
      setKnob(joyVec.x, joyVec.y);
      joystickMag.textContent = j.mag.toFixed(2);
    });

    joystick.addEventListener("pointerup", async () => {
      joyActive = false;
      started = true;

      // magnitude in [0,1]
      const mag = Math.min(1.0, Math.sqrt(joyVec.x*joyVec.x + joyVec.y*joyVec.y));

      // convert joystick into dv (world units)
      let dvx = joyVec.x * JOY_GAIN * mag;
      let dvy = -joyVec.y * JOY_GAIN * mag; // invert y

      // clamp to max
      const m = Math.sqrt(dvx*dvx + dvy*dvy);
      if (m > JOY_DV_MAX) {
        dvx = dvx / m * JOY_DV_MAX;
        dvy = dvy / m * JOY_DV_MAX;
      }

      // apply burn
      if (Math.abs(dvx) > 1e-6 || Math.abs(dvy) > 1e-6) {
        await apiPlan(dvx, dvy);
      }

      // reset knob visually
      joyVec = {x: 0, y: 0};
      setKnob(0, 0);
      joystickMag.textContent = "0.00";
    });

    // -----------------------------
    // Main loop
    // -----------------------------
    let lastTime = performance.now();
    async function tick(now) {
      const elapsed = (now - lastTime) / 1000;
      lastTime = now;

      if (state) {
        // step while running
        if (started && state.hud.status === "running") {
          try {
            await apiStep(STEP_DT);
          } catch (e) {
            console.error(e);
            setStatus("bad", "backend error");
          }
        }
        updateRenderCamera();
        render();
      }

      requestAnimationFrame(tick);
    }

    // -----------------------------
    // Boot
    // -----------------------------
    (async function boot(){
      setStatus("wait", "connecting...");
      try {
        await apiGetState();
        await apiReset();
        setStatus("wait", "ready");
        requestAnimationFrame(tick);
      } catch (e) {
        console.error(e);
        setStatus("bad", "cannot connect");
        statusText.textContent = "cannot connect";
        alert("Could not connect to backend at http://127.0.0.1:5000.\nStart Flask app.py first.");
      }
    })();
  </script>
</body>
</html>
